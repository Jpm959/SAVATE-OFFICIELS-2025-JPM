                `;
            }).join('');

            container.innerHTML = `
                <div class="final-result-container">
                    <div class="final-result-title">üèÜ R√âSULTAT FINAL OFFICIEL</div>
                    <div class="final-result-details">${finalResult}</div>
                    <div style="font-size: 16px; margin: 10px 0;">
                        Majorit√©: ${Math.max(redVotes, blueVotes)}/${completedJudges.length} juges
                    </div>
                    
                    <div class="majority-details">
                        <h4 style="margin-bottom: 15px;">D√©tail des votes des juges:</h4>
                        ${majorityDetails}
                    </div>
                    
                    <div style="margin-top: 20px; font-size: 14px; color: #666;">
                        Calcul automatique bas√© sur la majorit√© des d√©cisions
                    </div>
                </div>
            `;

            // Sauvegarder le r√©sultat final
            app.data.results = {
                finalResult: finalResult,
                redVotes: redVotes,
                blueVotes: blueVotes,
                judgeVotes: judgeVotes,
                timestamp: Date.now()
            };
        }

        // =====================
        // FONCTIONS D'EXPORT D√âL√âGU√â
        // =====================

        function exportCompleteMatchSheet() {
            // Export Excel complet
            const data = [
                ['FEUILLE DE MATCH COMPL√àTE - SAVATE BOXE FRAN√áAISE'],
                [''],
                ['Session:', app.session.code],
                ['Type:', getFightTypeLabel(app.session.fightType)],
                ['Date:', new Date().toLocaleDateString('fr-FR')],
                [''],
                ['Tireur Rouge:', app.data.fighters.red || 'Non d√©fini'],
                ['Tireur Bleu:', app.data.fighters.blue || 'Non d√©fini'],
                ['']
            ];

            // Ajouter les donn√©es de chaque juge
            Object.keys(app.data.judges).forEach(judgeKey => {
                const judge = app.data.judges[judgeKey];
                data.push([`JUGE ${judge.id} - ${judge.name}`]);
                data.push(['R√©sultat:', judge.result || 'En cours']);
                data.push(['Total Rouge:', judge.totalRed || 0]);
                data.push(['Total Bleu:', judge.totalBlue || 0]);
                data.push(['']);
            });

            if (app.data.results) {
                data.push(['R√âSULTAT FINAL:', app.data.results.finalResult]);
                data.push(['Votes Rouge:', app.data.results.redVotes]);
                data.push(['Votes Bleu:', app.data.results.blueVotes]);
            }

            downloadCSV(data, `feuille_match_complete_${app.session.code}_${formatDate(Date.now())}.csv`);
            showNotification('üìä Export Excel complet r√©alis√©!', 'success');
        }

        function exportOfficialReport() {
            // Export Markdown officiel
            let markdown = '# RAPPORT OFFICIEL - SAVATE BOXE FRAN√áAISE\n\n';
            markdown += `## Informations de la rencontre\n`;
            markdown += `- **Code de session:** ${app.session.code}\n`;
            markdown += `- **Type:** ${getFightTypeLabel(app.session.fightType)}\n`;
            markdown += `- **Date:** ${new Date().toLocaleDateString('fr-FR')}\n`;
            markdown += `- **Heure:** ${new Date().toLocaleTimeString('fr-FR')}\n\n`;
            
            markdown += `## Tireurs\n`;
            markdown += `- **Coin Rouge:** ${app.data.fighters.red || 'Non d√©fini'}\n`;
            markdown += `- **Coin Bleu:** ${app.data.fighters.blue || 'Non d√©fini'}\n\n`;
            
            markdown += `## Juges connect√©s\n`;
            Object.keys(app.data.judges).forEach(judgeKey => {
                const judge = app.data.judges[judgeKey];
                markdown += `### Juge ${judge.id} - ${judge.name}\n`;
                markdown += `- **Num√©ro:** ${judge.number}\n`;
                markdown += `- **R√©sultat:** ${judge.result || 'En cours'}\n`;
                markdown += `- **Score Rouge:** ${judge.totalRed || 0}\n`;
                markdown += `- **Score Bleu:** ${judge.totalBlue || 0}\n\n`;
            });

            if (app.data.results) {
                markdown += `## üèÜ R√âSULTAT FINAL OFFICIEL\n`;
                markdown += `**${app.data.results.finalResult}**\n\n`;
                markdown += `- Votes pour le coin rouge: ${app.data.results.redVotes}\n`;
                markdown += `- Votes pour le coin bleu: ${app.data.results.blueVotes}\n\n`;
            }

            markdown += `---\n_Rapport g√©n√©r√© le ${new Date().toLocaleString('fr-FR')}_`;
            
            downloadText(markdown, `rapport_officiel_${app.session.code}_${formatDate(Date.now())}.md`);
            showNotification('üìã Rapport officiel export√©!', 'success');
        }

        function exportRawData() {
            // Export JSON complet
            const exportData = {
                session: app.session,
                fighters: app.data.fighters,
                judges: app.data.judges,
                results: app.data.results,
                changeLog: app.data.changeLog,
                exportTimestamp: Date.now(),
                version: app.version
            };

            downloadJSON(exportData, `donnees_brutes_${app.session.code}_${formatDate(Date.now())}.json`);
            showNotification('üìù Donn√©es brutes export√©es!', 'success');
        }

        function printFinalResult() {
            // Version imprimable
            if (!app.data.results) {
                showNotification('‚ö†Ô∏è Aucun r√©sultat final √† imprimer', 'warning');
                return;
            }

            const printWindow = window.open('', '_blank');
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>R√©sultat Final - ${app.session.code}</title>
                    <style>
                        body { font-family: Arial, sans-serif; padding: 20px; }
                        h1 { text-align: center; color: #2c3e50; }
                        .result { background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 20px 0; }
                        .details { margin: 20px 0; }
                        .judge-vote { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid #ddd; }
                        .winner { font-weight: bold; color: #27ae60; }
                    </style>
                </head>
                <body>
                    <h1>üèÜ R√âSULTAT FINAL OFFICIEL</h1>
                    <div class="result">
                        <h2>${app.data.results.finalResult}</h2>
                        <p><strong>Majorit√©:</strong> ${Math.max(app.data.results.redVotes, app.data.results.blueVotes)}/${Object.keys(app.data.judges).length} juges</p>
                    </div>
                    
                    <div class="details">
                        <h3>D√©tail des votes:</h3>
                        ${Object.keys(app.data.results.judgeVotes).map(judgeKey => {
                            const judge = app.data.judges[judgeKey];
                            return `<div class="judge-vote"><span>Juge ${judge.id} (${judge.name})</span><span class="winner">${judge.result}</span></div>`;
                        }).join('')}
                    </div>
                    
                    <div style="margin-top: 40px; text-align: center; color: #666;">
                        Session: ${app.session.code} - ${new Date().toLocaleString('fr-FR')}
                    </div>
                
    
    <script>

        console.log('üöÄ SAVATE OFFICIALS - Interface CPTE Compl√®te Initialis√©e');
        console.log('üì± Version: 4.2.0 - Interface CPTE Professionnelle Finalis√©e');
        console.log('üîß Fonctionnalit√©s: WebRTC P2P + CPTE Compl√®te + Onglets D√©l√©gu√© + Validation + Export');

        // =====================
        // VARIABLES GLOBALES COMPL√àTES
        // =====================
        
        let app = {
            version: '4.2.0',
            webrtc: {
                peer: null,
                connections: new Map(),
                isHost: false,
                peerId: null,
                lastSyncTime: Date.now(),
                syncCount: 0,
                syncErrors: 0,
                reconnectAttempts: 0,
                maxReconnectAttempts: 5,
                connectionQuality: 'excellent',
                latency: 0
            },
            session: {
                id: '',
                code: '',
                fightType: 'assaut',
                judgeCount: 3,
                rounds: 3,
                initialized: false,
                role: '',
                judgeId: null,
                judgeName: '',
                judgeNumber: '',
                deviceId: 'device_' + Math.random().toString(36).substr(2, 9),
                startTime: null,
                status: 'inactive'
            },
            data: {
                judges: {},
                fighters: { red: '', blue: '' },
                connectedDevices: new Set(),
                changeLog: [],
                results: null
            },
            monitoring: {
                syncMetrics: {
                    totalSync: 0,
                    syncErrors: 0,
                    uptimeStart: Date.now()
                }
            }
        };

        // Variables CPTE (identiques au fichier SO J2 BONNE)
        const warnings = { red: {}, blue: {} };
        const comptes = { red: {}, blue: {} };
        const abandons = { red: false, blue: false };
        let actionHistory = [];
        let delegateActionHistory = []; // Historique des actions du d√©l√©gu√©
        let activeRounds = 3;
        
        // =====================
        // UTILITAIRES
        // =====================
        
        function generateSessionId() {
            return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function generateUniqueCode() {
            return Math.floor(1000 + Math.random() * 9000).toString();
        }

        function getFightTypeLabel(type) {
            const labels = {
                'assaut': 'Assaut (3 reprises)',
                'combat2espoirs': 'Combat 2√®me S√©rie Espoirs (3 reprises)',
                'combat2seniors': 'Combat 2√®me S√©rie Seniors (4 reprises)', 
                'combat1juniors': 'Combat 1√®re S√©rie Juniors (4 reprises)',
                'combat1seniors': 'Combat 1√®re S√©rie Seniors (5 reprises)'
            };
            return labels[type] || type;
        }

        function getRoundsFromFightType(fightType) {
            switch(fightType) {
                case 'assaut':
                case 'combat2espoirs':
                    return 3;
                case 'combat2seniors':
                case 'combat1juniors':
                    return 4;
                case 'combat1seniors':
                    return 5;
                default:
                    return 3;
            }
        }

        function isCombat() {
            return app.session.fightType !== 'assaut';
        }

        function formatTime(timestamp) {
            return new Date(timestamp).toLocaleTimeString('fr-FR');
        }

        function formatDate(timestamp) {
            return new Date(timestamp).toISOString().split('T')[0];
        }

        function safeGetElement(id) {
            return document.getElementById(id);
        }

        function showNotification(message, type = 'info', duration = 5000) {
            const notification = document.createElement('div');
            notification.className = `message ${type}`;
            notification.innerHTML = `
                ${message}
                <button onclick="this.parentElement.remove()" style="background: none; border: none; color: inherit; float: right; cursor: pointer;">√ó</button>
            `;
            
            const container = document.querySelector('.app-container');
            container.insertBefore(notification, container.firstChild);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, duration);
        }

        // =====================
        // GESTION HISTORIQUE D√âL√âGU√â
        // =====================

        function saveDelegateState(actionType, actionData = {}) {
            const state = {
                timestamp: Date.now(),
                actionType: actionType,
                actionData: actionData,
                session: JSON.parse(JSON.stringify(app.session)),
                fighters: JSON.parse(JSON.stringify(app.data.fighters)),
                judges: JSON.parse(JSON.stringify(app.data.judges)),
                results: JSON.parse(JSON.stringify(app.data.results))
            };
            
            delegateActionHistory.push(state);
            
            // Limiter l'historique √† 20 actions pour √©viter la surcharge m√©moire
            if (delegateActionHistory.length > 20) {
                delegateActionHistory.shift();
            }
            
            // Activer le bouton annuler
            const undoButton = document.getElementById('delegateUndoButton');
            if (undoButton) {
                undoButton.disabled = false;
                undoButton.textContent = `‚Ü∂ ANNULER: ${actionType}`;
            }
            
            console.log(`üíæ √âtat d√©l√©gu√© sauvegard√©: ${actionType}`, state);
        }

        function undoDelegateLastAction() {
            if (delegateActionHistory.length === 0) {
                showNotification('‚ùå Aucune action √† annuler', 'warning');
                return;
            }
            
            const previousState = delegateActionHistory.pop();
            
            console.log(`‚Ü∂ Annulation action d√©l√©gu√©: ${previousState.actionType}`);
            
            // Restaurer l'√©tat pr√©c√©dent
            app.session = previousState.session;
            app.data.fighters = previousState.fighters;
            app.data.judges = previousState.judges;
            app.data.results = previousState.results;
            
            // Envoyer la restauration aux juges connect√©s
            sendToAll({
                type: 'delegate_undo_action',
                data: {
                    actionType: previousState.actionType,
                    session: app.session,
                    fighters: app.data.fighters,
                    timestamp: Date.now()
                }
            }, 'high');
            
            // Mettre √† jour l'interface d√©l√©gu√©
            updateDelegateInterface();
            
            // Mettre √† jour le bouton annuler
            const undoButton = document.getElementById('delegateUndoButton');
            if (undoButton) {
                if (delegateActionHistory.length === 0) {
                    undoButton.disabled = true;
                    undoButton.textContent = '‚Ü∂ ANNULER DERNI√àRE ACTION';
                } else {
                    const nextAction = delegateActionHistory[delegateActionHistory.length - 1];
                    undoButton.textContent = `‚Ü∂ ANNULER: ${nextAction.actionType}`;
                }
            }
            
            showNotification(`‚Ü∂ Action "${previousState.actionType}" annul√©e avec succ√®s`, 'success');
        }

        function updateDelegateInterface() {
            // Mettre √† jour les noms des tireurs
            const redName = document.getElementById('fighterRedName');
            const blueName = document.getElementById('fighterBlueName');
            if (redName) redName.value = app.data.fighters.red || '';
            if (blueName) blueName.value = app.data.fighters.blue || '';
            
            // Mettre √† jour le monitoring et les tableaux
            if (app.session.role === 'delegate' && app.session.initialized) {
                updateJudgeMonitoring();
                updateRecapTable();
                updateFinalResult();
            }
        }

        // =====================
        // WEBRTC SYST√àME
        // =====================
        
        function waitForPeerJS(maxWaitTime = 15000) {
            return new Promise((resolve, reject) => {
                let elapsed = 0;
                const checkInterval = 100;
                
                const checkPeerJS = () => {
                    if (typeof Peer !== 'undefined') {
                        console.log('‚úÖ PeerJS charg√©');
                        resolve();
                        return;
                    }
                    
                    elapsed += checkInterval;
                    if (elapsed >= maxWaitTime) {
                        reject(new Error('PeerJS timeout'));
                        return;
                    }
                    
                    setTimeout(checkPeerJS, checkInterval);
                };
                
                checkPeerJS();
            });
        }

        function initializeWebRTC() {
            return new Promise((resolve, reject) => {
                waitForPeerJS().then(() => {
                    try {
                        const baseId = app.session.role === 'delegate' ? 
                            `delegate_${app.session.code}` : 
                            `judge_${app.session.code}_${Date.now()}`;
                        
                        console.log('üåê Initialisation WebRTC:', baseId);
                        
                        app.webrtc.peer = new Peer(baseId, {
                            config: {
                                'iceServers': [
                                    { urls: 'stun:stun.l.google.com:19302' },
                                    { urls: 'stun:stun1.l.google.com:19302' }
                                ]
                            }
                        });

                        app.webrtc.peer.on('open', function(id) {
                            console.log('‚úÖ Peer WebRTC cr√©√©:', id);
                            app.webrtc.peerId = id;
                            updateSyncIndicator('Connect√© WebRTC', 'connected');
                            
                            if (app.session.role === 'delegate') {
                                app.webrtc.isHost = true;
                            }
                            
                            resolve(id);
                        });

                        app.webrtc.peer.on('connection', function(conn) {
                            console.log('üìû Connexion entrante:', conn.peer);
                            handleIncomingConnection(conn);
                        });

                        app.webrtc.peer.on('error', function(err) {
                            console.error('‚ùå Erreur WebRTC:', err);
                            updateSyncIndicator('Erreur: ' + err.type, 'offline');
                            
                            if (err.type === 'peer-unavailable') {
                                showNotification('‚ùå Session introuvable. V√©rifiez le code.', 'error');
                            } else {
                                showNotification('‚ùå Erreur WebRTC: ' + err.type, 'error');
                            }
                            
                            reject(err);
                        });

                        setTimeout(() => {
                            if (!app.webrtc.peerId) {
                                reject(new Error('Timeout WebRTC'));
                            }
                        }, 15000);

                    } catch (error) {
                        console.error('‚ùå Erreur init WebRTC:', error);
                        reject(error);
                    }
                }).catch(error => {
                    console.error('‚ùå PeerJS indisponible:', error);
                    updateSyncIndicator('‚ùå PeerJS indisponible', 'offline');
                    showNotification('‚ùå Impossible de charger PeerJS', 'error');
                    reject(error);
                });
            });
        }

        function handleIncomingConnection(conn) {
            app.webrtc.connections.set(conn.peer, conn);
            
            conn.on('open', function() {
                console.log('‚úÖ Connexion √©tablie:', conn.peer);
                updatePeersList();
                
                if (app.session.role === 'delegate') {
                    sendSessionDataToNewPeer(conn);
                }
            });

            conn.on('data', function(data) {
                handleWebRTCMessage(data, conn.peer, conn);
            });

            conn.on('close', function() {
                console.log('üîå Connexion ferm√©e:', conn.peer);
                app.webrtc.connections.delete(conn.peer);
                updatePeersList();
                cleanupJudgeData(conn.peer);
            });

            conn.on('error', function(err) {
                console.error('‚ùå Erreur connexion:', err);
                app.webrtc.connections.delete(conn.peer);
                updatePeersList();
            });
        }

        function connectToPeer(peerId) {
            return new Promise((resolve, reject) => {
                try {
                    console.log('üîó Connexion au peer:', peerId);
                    updateSyncIndicator('Connexion...', 'syncing');
                    
                    const conn = app.webrtc.peer.connect(peerId, {
                        reliable: true,
                        serialization: 'json'
                    });
                    
                    conn.on('open', function() {
                        console.log('‚úÖ Connect√© au d√©l√©gu√©:', peerId);
                        app.webrtc.connections.set(peerId, conn);
                        updateSyncIndicator('Connect√©', 'connected');
                        updatePeersList();
                        
                        sendJudgeConnectionData(conn);
                        resolve(conn);
                    });

                    conn.on('data', function(data) {
                        handleWebRTCMessage(data, peerId, conn);
                    });

                    conn.on('close', function() {
                        console.log('üîå Connexion ferm√©e');
                        app.webrtc.connections.delete(peerId);
                        updateSyncIndicator('D√©connect√©', 'offline');
                        updatePeersList();
                    });

                    conn.on('error', function(err) {
                        console.error('‚ùå Erreur connexion:', err);
                        updateSyncIndicator('Erreur', 'offline');
                        reject(err);
                    });

                    setTimeout(() => {
                        if (!app.webrtc.connections.has(peerId)) {
                            reject(new Error('Timeout connexion'));
                        }
                    }, 20000);

                } catch (error) {
                    console.error('‚ùå Erreur connectToPeer:', error);
                    reject(error);
                }
            });
        }

        function sendToAll(message, priority = 'normal') {
            const enrichedMessage = {
                ...message,
                timestamp: Date.now(),
                from: app.webrtc.peerId,
                fromRole: app.session.role,
                sessionCode: app.session.code,
                priority: priority
            };
            
            let sentCount = 0;
            let errorCount = 0;
            
            app.webrtc.connections.forEach((conn, peerId) => {
                if (conn.open) {
                    try {
                        conn.send(enrichedMessage);
                        sentCount++;
                    } catch (error) {
                        console.error('‚ùå Erreur envoi:', peerId, error);
                        errorCount++;
                    }
                } else {
                    errorCount++;
                }
            });
            
            console.log(`üì§ Message envoy√© √† ${sentCount} peers:`, message.type);
            return { sent: sentCount, errors: errorCount };
        }

        function handleWebRTCMessage(message, fromPeer, conn) {
            console.log('üì• Message re√ßu:', message.type, 'de', fromPeer);
            
            try {
                switch (message.type) {
                    case 'judge_connection':
                        handleJudgeConnection(message.data, fromPeer);
                        break;
                    case 'judge_data':
                        receiveJudgeData(message.data, message);
                        break;
                    case 'session_data':
                        receiveSessionData(message.data);
                        break;
                    case 'fighter_names':
                        receiveFighterNames(message.data);
                        break;
                    case 'partial_reset_command':
                        if (app.session.role === 'judge') {
                            console.log('üî• Commande de r√©initialisation partielle re√ßue du d√©l√©gu√©');
                            app.data.fighters = message.data.fighters;
                            updateFighterNamesInInterface();
                            resetJudgeFormData();
                            showNotification('üîÑ R√©initialisation effectu√©e par le d√©l√©gu√©', 'warning');
                        }
                        break;
                    case 'delegate_undo_action':
                        if (app.session.role === 'judge') {
                            console.log('‚Ü∂ Annulation d\'action re√ßue du d√©l√©gu√©:', message.data.actionType);
                            if (message.data.session) {
                                const currentJudgeName = app.session.judgeName;
                                const currentJudgeNumber = app.session.judgeNumber;
                                const currentJudgeId = app.session.judgeId;
                                const currentRole = app.session.role;
                                
                                app.session = { ...app.session, ...message.data.session };
                                
                                app.session.judgeName = currentJudgeName;
                                app.session.judgeNumber = currentJudgeNumber;
                                app.session.judgeId = currentJudgeId;
                                app.session.role = currentRole;
                            }
                            
                            if (message.data.fighters) {
                                app.data.fighters = message.data.fighters;
                                updateFighterNamesInInterface();
                            }
                            
                            updateJudgeRounds();
                            createJudgeTableStructure();
                            
                            showNotification(`‚Ü∂ Action "${message.data.actionType}" annul√©e par le d√©l√©gu√©`, 'info');
                        }
                        break;
                    case 'session_reset_complete':
                        if (app.session.role === 'judge') {
                            console.log('üî• Session r√©initialis√©e par le d√©l√©gu√©');
                            showNotification('‚ö†Ô∏è Session r√©initialis√©e par le d√©l√©gu√©. D√©connexion...', 'warning');
                            setTimeout(() => {
                                resetJudgeConnection();
                            }, 2000);
                        }
                        break;
                    case 'judge_disconnect':
                        if (app.session.role === 'delegate') {
                            console.log('üî• Juge d√©connect√©:', message.data);
                            const judgeKey = `judge${message.data.judgeId}`;
                            
                            if (app.data.judges[judgeKey]) {
                                app.data.judges[judgeKey].connected = false;
                                app.data.judges[judgeKey].lastUpdate = Date.now();
                                updateJudgeMonitoring();
                                showNotification(`üö™ ${message.data.name} s'est d√©connect√©`, 'info');
                            }
                        }
                        break;
                    default:
                        console.warn('‚ö†Ô∏è Type message non reconnu:', message.type);
                }
            } catch (error) {
                console.error('‚ùå Erreur traitement message:', error);
            }
        }

        function handleJudgeConnection(connectionData, fromPeer) {
            console.log('üì• Connexion juge:', connectionData);
            const judgeKey = `judge${connectionData.judgeId}`;
            
            if (!app.data.judges[judgeKey]) {
                app.data.judges[judgeKey] = {
                    id: connectionData.judgeId,
                    scores: {},
                    warnings: { red: {}, blue: {} },
                    comptes: { red: {}, blue: {} },
                    abandons: { red: false, blue: false },
                    bonuses: { red: 0, blue: 0 },
                    totalRed: 0,
                    totalBlue: 0,
                    result: 'En attente...'
